Please answer the below Data Structure Questions:

why do we need data structure?
A. Data structures are act as vital elements of any organization and organize data more efficiently and support to build more complex
   applications.More complex applications demand more calculations.Complex computing tasks are unlike our everyday experience.
What are the various operations that can be performed on different Data Structures?
List out the areas in which data structures are applied extensively?
A. Compiler Design, Operating system, Database Management System, Statistical analysis package,
   Numerical Analysis, Graphics, Artificial Intelligence, Simulation.
what is an Array?
A. An array is a container object that holds a fixed number of values of a single type.
what is the difference between the Array and ArrayList?
A. Resizable : Array is static in size that is fixed length data structure, One can not change the length after creating the Array object.
   ArrayList is dynamic in size. Each ArrayList object has instance variable capacity which indicates the size of the ArrayList.
   As elements are added to an ArrayList its capacity grows automatically.
what is LinkedList?
A. A linked list is a linear collection of data elements, called nodes, each pointing to the next node by means of a
   pointer. It is a data structure consisting of a group of nodes which together represent a sequence.
How is an Array different from Linked List?
A. The major difference between Array and Linked list regards to their structure. Arrays are index based data structure where each element associated with an index
what is queue?
A. It represents an ordered list of objects just like a List , but its intended use is slightly different.
  A queue is designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue.

what is stack?
A. A stack is a data structure that allows data to be inserted (a 'push' operation), and removed (a 'pop' operation).
   Many stacks also support a read ahead (a 'peek' operation), which reads data without removing it.
   A stack is a LIFO-queue, meaning that the last data to be inserted will be the first data to be removed.
what is FIFO and LIFO?
A. First in first out and last in first out
what is the order of complexity?
A. Big O notation is that we are measuring the time and space complexity of an algorithm in terms of the growth of input size n.
what is the best case to search an element from an array?
A. O(n)
what is the worst case to search an element from an array?
A. O(n)
what is tree in data structure?
A. trees are made up of nodes. A common kind of tree is a binary tree, in which each node contains a reference to two
   other nodes (possibly null).
what is graph in data structure?
A. A graph is an object consisting of a vertex set and an edge set.
what is the difference between the HashTable and HashMap?
A. Hashtable is synchronized whereas hashmap is not. 2)Another difference is that iterator in the HashMap is fail-safe
What are the major data structures used in the following areas : RDBMS, Network data model and Hierarchical data model.
A. RDBMS = Array (i.e. Array of structures)
   Network data model = Graph
   Hierarchical data model = Trees
How HashMap works in java?
A. HashMap works on the principal of hashing.
   Map.Entry interface - This interface gives a map entry (key-value pair). HashMap in Java stores both key and value object, in bucket, as an object of Entry class which implements this nested interface Map.Entry.
   hashCode() -HashMap provides put(key, value) for storing and get(key) method for retrieving Values from HashMap. When put() method is used to store (Key, Value) pair, HashMap implementation calls hashcode on
   Key object to calculate a hash that is used to find a bucket where Entry object will be stored. When get() method is used to retrieve value, again key object is used to calculate a hash which is used then to find a bucket where that particular key is stored.
   equals() - equals() method is used to compare objects for equality. In case of HashMap key object is used for comparison, also using equals() method Map knows how to handle hashing collision (hashing collision means more than one key having the same hash value,
   thus assigned to the same bucket. In that case objects are stored in a linked list, refer figure for more clarity.
   Where hashCode method helps in finding the bucket where that key is stored, equals method helps in finding the right key as there may be more than one key-value pair stored in a single bucket.

What is ArrayIndexOutOfBoundsException in java? When it occurs?
A. Every runtime problem, in Java, is represented by a class. For example, the problem of accessing an array element beyond the size of array is represented by a class known as ArrayIndexOutOfBoundsException (from java.lang package).

What are the different ways of copying an array into another array?
A. 1. An own implementation of an copying algorithm.
   2. use of API functions.
What is difference between an array and a linked list?
A. Fundamentally, an array is a pre-allocated block of memory holding an ordered bunch of items. A linked list is a data structure with no pre-allocated memory, but rather each item in the list contains the address of "adjacent"
   items (the next one and the previous one).
   To access a specific element N in an array, it's as simple as getting the address of the first one, then adding N to that address. Instant retrieval of data.
   To access a specific element N in a linked list, we need to iterate through the list because there's no indication of where element N is, just where the next one is.
   To reorder elements N and M in an array, it's as simple as copying the data from element N to a third location, writing the data from element M into location N, then writing the data from element N to location M.
   (Third location necessary to do the swap).  If our objects are huge, then this means a lot of data copying and it may be horribly inefficient to do so.
   To reorder elements N and M in a linked list, we must first retrieve the memory locations of both, but then all that has to be done is to swap the pointers -- that is, make N-1 point to M, M point to N+1, M-1 point to N, and N point to N+1.
   These pointers are small in memory size, so swapping them is trivial.  If our objects are small, then there are more swaps involved than reordering an array, but if they're big then we've saved ourself a buttload of time and memory by avoiding
   having to actually move the object from one memory location to another.

What is DFS and BFS?
A. DFS (Depth First Search) and BFS (Breadth First Search) are search algorithms used for graphs and trees. When we have an ordered tree or graph, like a BST, it’s quite easy to search the data structure to find the node that we want.
   But, when given an unordered tree or graph, the BFS and DFS search algorithms can come in handy to find what we’re looking for. The decision to choose one over the other should be based on the type of data that one is dealing with.
   In a breadth first search, we start at the root node, and then scan each node in the first level starting from the leftmost node, moving towards the right. Then we continue scanning the second level (starting from the left) and the
   third level, and so on until we’ve scanned all the nodes, or until we find the actual node that we were searching for. In a BFS, when traversing one level, we need some way of knowing which nodes to traverse once we get to the next level.
   The way this is done is by storing the pointers to a level’s child nodes while searching that level. The pointers are stored in FIFO (First-In-First-Out) queue. This, in turn, means that BFS uses a large amount of memory because
   we have to store the pointers.
   In a depth first search, we start at the root, and follow one of the branches of the tree as far as possible until either the node we are looking for is found or we hit a leaf node ( a node with no children). If we hit a leaf node,
   then we continue the search at the nearest ancestor with unexplored children.

What is Recursion?
A. Recursion in computer science is a method where the solution to a problem depends on solutions to smaller instances of the same problem (as opposed to iteration).The approach can be applied to many types of problems, and recursion is
   one of the central ideas of computer science

What are linear and non linear data Structures?
A. Examples of linear data structures are Arrays, Stack, Queue and Linked List. Non Linear Data Structures: The data structure where data items are not organized sequentially is called non linear data structure.
What is Big-(O)-notation?
A. Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity.
   In computer science, big O notation is used to classify algorithms by how they respond to changes in input size, such as how the processing time of an algorithm changes as the problem size becomes extremely large.
   In analytic number theory it is used to estimate the "error committed" while replacing the asymptotic size of an arithmetical function by the value it takes at a large finite argument. A famous example is the problem of
   estimating the remainder term in the prime number theorem.

Outlined different kind of sorting algorithm with time complexity?
A. Bubble Sort [Best: O(n), Worst:O(N^2)]
   Selection Sort [Best/Worst: O(N^2)]
   Insertion Sort [Best: O(N), Worst:O(N^2)]
   Quicksort [Best: O(N lg N), Avg: O(N lg N), Worst:O(N^2)]
   Heapsort [Best/Avg/Worst: O(N lg N)]
   Counting sort [Best/Avg/Worst: O(N)]
   Radix sort [Best/Avg/Worst: O(N)]

Draw a table with time complexity in which it will summarize all the data structure feature's advantages and disadvantages.
  a)In terms of Accessing element.
  b)In terms of Inserting element.
  c)In terms of Searching element.
  d)In terms of Removing element.
Data Structure                  |  Accessing  | Inserting | Searching | Removing
--------------------------------------------------------------------------------
Array (T[])                     |    O(1)     |    O(N)   |    O(N)   |   O(N)
--------------------------------------------------------------------------------
Linked List (LinkedList<T>)     |    O(N)     |    O(1)   |    O(N)   |   O(N)
--------------------------------------------------------------------------------
Dynamic Array (List<T>)         |    O(1)     |    O(1)   |    O(N)   |   O(N)
--------------------------------------------------------------------------------
Stack (Stack<T>)                |     -       |    O(1)   |     -     |     -
--------------------------------------------------------------------------------
Queue (Queue<T>)                |     -       |    O(1)   |     -     |   O(1)
--------------------------------------------------------------------------------
Dictionary, implemented with    |     -       |    O(1)   |     O(1)  |   O(1)
a hash-table(Dictionary<k,T>
--------------------------------------------------------------------------------
Dictionary, implemented witha   |     -       |  O(log(N))| O(log(N)) |O(log(N))
balanced search tree
(SortedDictionary<K, T>)
--------------------------------------------------------------------------------
Set, implemented with a         |     -       |    O(1)   |  O(1)     |  O(1)
hash-table (HashSet<T>)
--------------------------------------------------------------------------------
set,implemented with a balanced |     -       |  O(log(N))| O(log(N)) |O(log(N))
search tree (SortedSet<T>)
--------------------------------------------------------------------------------

